/**
 * Divides one tensor by another element-wise.
 *
 * @param context The GGML context
 * @param a The numerator tensor
 * @param b The denominator tensor
 * @return The result tensor (a / b)
 */
fun computeDiv(@Suppress("unused") context: GGMLContext, a: GGMLTensor, b: GGMLTensor): GGMLTensor {
    // Check that the tensors have compatible dimensions
    for (i in 0 until GGML_MAX_DIMS) {
        if (a.ne[i] != b.ne[i]) {
            throw IllegalArgumentException("Incompatible dimensions for division")
        }
    }

    // Create a new tensor for the result with the same dimensions as a
    val result = GGMLTensor(type = a.type)
    for (i in 0 until GGML_MAX_DIMS) {
        result.ne[i] = a.ne[i]
        result.nb[i] = a.nb[i]
    }

    // Calculate total size
    val totalSize = calculateTotalSize(a.ne)

    // Perform division based on the tensor type
    when (a.type) {
        GGMLType.F32 -> {
            val aData = a.data as FloatArray
            val bData = b.data as FloatArray
            val resultData = FloatArray(totalSize)

            // Process in chunks for better cache utilization
            val chunkSize = 128
            var i = 0
            while (i < totalSize) {
                val end = minOf(i + chunkSize, totalSize)
                for (j in i until end) {
                    if (bData[j] == 0.0f) {
                        // Handle division by zero
                        resultData[j] = if (aData[j] == 0.0f) {
                            Float.NaN // 0/0 = NaN
                        } else if (aData[j] > 0.0f) {
                            Float.POSITIVE_INFINITY // positive/0 = +Infinity
                        } else {
                            Float.NEGATIVE_INFINITY // negative/0 = -Infinity
                        }
                    } else {
                        resultData[j] = aData[j] / bData[j]
                    }
                }
                i = end
            }

            result.data = resultData
        }
        GGMLType.F16 -> {
            val aData = a.data as ShortArray
            val bData = b.data as ShortArray
            val resultData = ShortArray(totalSize)

            // Process in chunks for better cache utilization
            val chunkSize = 128
            var i = 0
            while (i < totalSize) {
                val end = minOf(i + chunkSize, totalSize)
                for (j in i until end) {
                    // Convert shorts to floats
                    val aFloat = aData[j].toFloat() / 32768.0f
                    val bFloat = bData[j].toFloat() / 32768.0f

                    // Perform division
                    val resultFloat = if (bFloat == 0.0f) {
                        if (aFloat == 0.0f) {
                            Float.NaN // 0/0 = NaN
                        } else if (aFloat > 0.0f) {
                            Float.POSITIVE_INFINITY // positive/0 = +Infinity
                        } else {
                            Float.NEGATIVE_INFINITY // negative/0 = -Infinity
                        }
                    } else {
                        aFloat / bFloat
                    }

                    // Convert back to short
                    resultData[j] = (resultFloat * 32768.0f).toInt().toShort()
                }
                i = end
            }

            result.data = resultData
        }
        GGMLType.I8 -> {
            val aData = a.data as ByteArray
            val bData = b.data as ByteArray
            val resultData = ByteArray(totalSize)

            // Process in chunks for better cache utilization
            val chunkSize = 128
            var i = 0
            while (i < totalSize) {
                val end = minOf(i + chunkSize, totalSize)
                for (j in i until end) {
                    if (bData[j] == 0.toByte()) {
                        // Handle division by zero - for integer types, we'll use 0 as a default
                        resultData[j] = 0
                    } else {
                        resultData[j] = (aData[j] / bData[j]).toByte()
                    }
                }
                i = end
            }

            result.data = resultData
        }
        GGMLType.I16 -> {
            val aData = a.data as ShortArray
            val bData = b.data as ShortArray
            val resultData = ShortArray(totalSize)

            // Process in chunks for better cache utilization
            val chunkSize = 128
            var i = 0
            while (i < totalSize) {
                val end = minOf(i + chunkSize, totalSize)
                for (j in i until end) {
                    if (bData[j] == 0.toShort()) {
                        // Handle division by zero - for integer types, we'll use 0 as a default
                        resultData[j] = 0
                    } else {
                        resultData[j] = (aData[j] / bData[j]).toShort()
                    }
                }
                i = end
            }

            result.data = resultData
        }
        GGMLType.I32 -> {
            val aData = a.data as IntArray
            val bData = b.data as IntArray
            val resultData = IntArray(totalSize)

            // Process in chunks for better cache utilization
            val chunkSize = 128
            var i = 0
            while (i < totalSize) {
                val end = minOf(i + chunkSize, totalSize)
                for (j in i until end) {
                    if (bData[j] == 0) {
                        // Handle division by zero - for integer types, we'll use 0 as a default
                        resultData[j] = 0
                    } else {
                        resultData[j] = aData[j] / bData[j]
                    }
                }
                i = end
            }

            result.data = resultData
        }
        GGMLType.I64 -> {
            val aData = a.data as LongArray
            val bData = b.data as LongArray
            val resultData = LongArray(totalSize)

            // Process in chunks for better cache utilization
            val chunkSize = 128
            var i = 0
            while (i < totalSize) {
                val end = minOf(i + chunkSize, totalSize)
                for (j in i until end) {
                    if (bData[j] == 0L) {
                        // Handle division by zero - for integer types, we'll use 0 as a default
                        resultData[j] = 0L
                    } else {
                        resultData[j] = aData[j] / bData[j]
                    }
                }
                i = end
            }

            result.data = resultData
        }
        GGMLType.Q4_0, GGMLType.Q4_1, GGMLType.Q5_0, GGMLType.Q5_1, GGMLType.Q8_0, GGMLType.Q8_1 -> {
            // For quantized types, we'll implement specialized code in the future
            // For now, we'll just set the result data to null
            result.data = null
        }
        else -> {
            // For other types, we'll implement later
            result.data = null
        }
    }

    return result
}
